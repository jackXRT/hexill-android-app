<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hexill Cracking Terminal</title>
  <style>
    body {
      background-color: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      margin: 0;
      padding: 10px;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .binary { color: #00cc00; }
    .hex { color: #ffaa00; }
    .highlight { color: #ffff00; font-weight: bold; }
    .private { color: #00ffff; font-weight: bold; }
    .error { color: #cc0000; font-weight: bold; }
    .hint { color: orange; font-weight: bold; }
  </style>
</head>
<body>
  <pre id="terminal">Booting Hexill cracking engine...</pre>

  <script>
    const terminal = document.getElementById("terminal");
    let bip39 = [];

    fetch("bip39-wordlist.txt")
      .then(res => res.text())
      .then(text => {
        bip39 = text.split("\n").map(w => w.trim()).filter(Boolean);
        startCracking();
      });

    function randomWord() {
      return bip39[Math.floor(Math.random() * bip39.length)];
    }

    function partialSeed() {
      return Array.from({ length: 4 }, randomWord).join(" ") + " ...";
    }

    function fakeBinary() {
      return `<span class="binary">${Array.from({ length: 100 }, () => Math.random() > 0.5 ? '1' : '0').join('')}</span>`;
    }

    function fakeHex() {
      const hexChars = 'abcdef0123456789';
      let out = '';
      for (let i = 0; i < 64; i++) {
        out += hexChars[Math.floor(Math.random() * hexChars.length)];
      }
      return `<span class="hex">${out}</span>`;
    }

    function fakeOp() {
      const ops = [
        "→ [PHASE 1] Seeding entropy core...",
        "→ Entropy shards gathered from pool: 0xC4",
        "→ Bitstream aligned: GPU Thread #7",
        "→ Running scrypt and bcrypt simultaneously...",
        "→ Recovering entropy fragment from cloud bucket...",
        "→ Memory overflow detected on segment 0x3e... bypassed.",
        "→ XOR cascade initiated across pipeline...",
        "→ Analyzing elliptic curve intersections...",
        "→ ECC scalar multiple points sorted...",
        "→ AES256 rotor stabilization complete.",
        "→ Extracting potential BIP32 derivations...",
        "→ Transaction address matches found on mempool...",
        "→ Stack entropy randomized with salt: 0xfadc",
        "→ CPU thread saturation: 91%...",
        "→ Parallel WIF signature probing in process...",
        "→ SHA3 entropy hash diverged... retrying...",
        "→ [PHASE 2] Initiating crypto brute threads...",
        "→ Vector length overflow avoided: new checksum computed.",
        "→ Loading historic BTC ledger from node...",
        "→ HD wallet alignment on m/44'/0'/0'/0/18",
        "→ Validating address reuse patterns across chains...",
        "→ Attempting chain sync... current block height 832103...",
        "→ Loading candidate brainwallet seeds...",
        "→ Reconstructing BIP39 shards from entropy pool...",
        "→ [PHASE 3] CPU affinity reassigned to cracking threads...",
        "→ Subroutine branch split across ECC vectors...",
        "→ Inverted hash tree reconstruction running...",
        "→ Injecting XOR faults for anti-recovery detection...",
        "→ Parallel entropy thread forked on GPU 3...",
        "→ Analyzing TornadoCash mixing patterns...",
        "→ Matching known public key hash collisions...",
      ];
      return ops[Math.floor(Math.random() * ops.length)];
    }

    function writeLine(text, delay = 400) {
      return new Promise(resolve => {
        setTimeout(() => {
          terminal.innerHTML += "\n" + text;
          window.scrollTo(0, document.body.scrollHeight);
          resolve();
        }, delay);
      });
    }

    async function startCracking() {
      await writeLine("System check OK");
      await writeLine("Cracking module: v4.2 loaded.");
      await writeLine("Entropy feed: SYNCHRONIZED");
      await writeLine("→ Boot sequence complete\n");

      // Initial operations
      for (let i = 0; i < 50; i++) {
        await writeLine(fakeOp(), 300 + Math.random() * 250);
      }

      // Long suspense: binary + hex + fakeOp interleaved
      for (let i = 0; i < 160; i++) {
        const type = Math.random();
        if (type < 0.4) {
          await writeLine(fakeBinary(), 150 + Math.random() * 100);
        } else if (type < 0.8) {
          await writeLine(fakeHex(), 150 + Math.random() * 100);
        } else {
          await writeLine(fakeOp(), 300 + Math.random() * 200);
        }

        // Inject occasional pause
        if (i % 20 === 0) {
          await writeLine(fakeOp(), 600 + Math.random() * 200);
        }
      }

      // Final suspense phase
      await writeLine("\n→ ECC vector alignment successful.");
      await writeLine("→ Deriving entropy offset key 0x17A92F...");
      await writeLine("→ Mnemonic probability pattern matches found.");
      await writeLine(`<span class="highlight">PARTIAL SEED PHRASE:</span> "${partialSeed()}"`);
      await writeLine(`<span class="private">PRIVATE KEY:</span> 5JxA6nmNqpK....PQddf3s`);
      await writeLine(`<span class="private">WIF KEY:</span> L1v64akdKeC...83gTnZ\n`);

      await writeLine(`<span class="error">[ERROR]</span> Final entropy node failed to finalize due to vector collision.`);
      await writeLine(`<span class="error">ACCESS DENIED:</span> Upgrade to Pro Tier required for GPU cracking module unlock.`);

      await writeLine(`<span class="hint">Upgrade to Pro</span> to unlock final 8 mnemonic words, decrypt export options, and enable raw seed download.`);
    }
  </script>
</body>
</html>
